/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
/*
 * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
 * Author: STM32CubeMX code generation for STMicroelectronics.
 */

/* For more information on Device Tree configuration, please refer to
 * https://wiki.st.com/stm32mpu/wiki/Category:Device_tree_configuration
 */

/dts-v1/;
#include <dt-bindings/pinctrl/stm32-pinfunc.h>

#include "stm32mp157.dtsi"
#include "stm32mp15xa.dtsi"

//Added from a-ev1
//#include "stm32mp15-pinctrl.dtsi"
//#include "stm32mp15xx-dkx.dtsi"
//

#include "stm32mp15xxac-pinctrl.dtsi"
#include "stm32mp157-m4-srm.dtsi"



/* USER CODE BEGIN includes */
/* USER CODE END includes */

/ {
	model = "STMicroelectronics custom STM32CubeMX board";
	compatible = "st,stm32mp157a-ugeast-mx", "st,stm32mp157";

	aliases {
		ethernet0 = &ethernet0;
		serial0 = &uart4;
		serial1 = &uart8;
		serial2 = &usart3;
		serial3 = &uart7;
		serial4 = &usart1;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};


	memory@c0000000 {
		device_type = "memory";
		reg = <0xc0000000 0x10000000>;

		/* USER CODE BEGIN memory */
		/* USER CODE END memory */
	};

	reserved-memory {
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		/* USER CODE BEGIN reserved-memory */

		/* USER CODE END reserved-memory */
	};

	/* USER CODE BEGIN root */

	vddcore: regulator-vddcore {
		compatible = "regulator-fixed";
		regulator-name = "vddcore";
		regulator-min-microvolt = <1200000>;
		regulator-max-microvolt = <1200000>;
		regulator-always-on;
	};

	vdd: regulator-vdd {
		compatible = "regulator-fixed";
		regulator-name = "vdd";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	vdd_usb: regulator-vdd_usb {
		compatible = "regulator-fixed";
		regulator-name = "vdd_usb";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	vdda: regulator-vdda {
		compatible = "regulator-fixed";
		regulator-name = "vdda";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	vdd_ddr: regulator-vdd_ddr {
		compatible = "regulator-fixed";
		regulator-name = "vdd_ddr";
		regulator-min-microvolt = <1350000>;
		regulator-max-microvolt = <1350000>;
		regulator-always-on;
	};

	vtt_ddr: regulator-vtt_ddr {
		compatible = "regulator-fixed";
		regulator-name = "vtt_ddr";
		regulator-min-microvolt = <675000>;
		regulator-max-microvolt = <675000>;
		regulator-always-on;
		vin-supply = <&vdd>;
	};

	vref_ddr: regulator-vref_ddr {
		compatible = "regulator-fixed";
		regulator-name = "vref_ddr";
		regulator-min-microvolt = <675000>;
		regulator-max-microvolt = <675000>;
		regulator-always-on;
		vin-supply = <&vdd>;
	};

	vdd_sd: regulator-vdd_sd {
		compatible = "regulator-fixed";
		regulator-name = "vdd_sd";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	v3v3: regulator-v3v3 {
		compatible = "regulator-fixed";
		regulator-name = "v3v3";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};

	v2v8: regulator-v2v8 {
		compatible = "regulator-fixed";
		regulator-name = "v2v8";
		regulator-min-microvolt = <2800000>;
		regulator-max-microvolt = <2800000>;
		regulator-always-on;
		vin-supply = <&v3v3>;
	};

	v1v8: regulator-v1v8 {
		compatible = "regulator-fixed";
		regulator-name = "v1v8";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		regulator-always-on;
		vin-supply = <&v3v3>;
	};

	vbus_otg: regulator-vbus_otg {
		compatible = "regulator-fixed";
		regulator-name = "vbus_otg";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
	};
	/* USER CODE BEGIN root */



	v3v3: regulator-v3v3 {
		compatible = "regulator-fixed";
		regulator-name = "v3v3";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
	};


	/* USER CODE END root */

	clocks {

		/* USER CODE BEGIN clocks */
		/* USER CODE END clocks */

#ifndef CONFIG_STM32MP1_TRUSTED
		clk_lsi: clk-lsi {
			clock-frequency = <32000>;
		};
		clk_hsi: clk-hsi {
			clock-frequency = <64000000>;
		};
		clk_csi: clk-csi {
			clock-frequency = <4000000>;
		};
		clk_lse: clk-lse {
			clock-frequency = <32768>;
		};
		clk_hse: clk-hse {
			clock-frequency = <24000000>;
		};
#endif	/*CONFIG_STM32MP1_TRUSTED*/
	};

}; /*root*/

&pinctrl {
	u-boot,dm-pre-reloc;





	sdmmc1_pins_mx: sdmmc1_mx-0 {
		u-boot,dm-pre-reloc;
		pins1 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
					 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
			bias-disable;
			drive-push-pull;
			slew-rate = <3>;
		};
	};

	sdmmc1_opendrain_pins_mx: sdmmc1_opendrain_mx-0 {
		u-boot,dm-pre-reloc;
		pins1 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
			bias-disable;
			drive-push-pull;
			slew-rate = <3>;
		};
		pins3 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
			bias-disable;
			drive-open-drain;
			slew-rate = <1>;
		};
	};

	sdmmc1_sleep_pins_mx: sdmmc1_sleep_mx-0 {
		u-boot,dm-pre-reloc;
		pins {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('C', 9, ANALOG)>, /* SDMMC1_D1 */
					 <STM32_PINMUX('C', 10, ANALOG)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('C', 11, ANALOG)>, /* SDMMC1_D3 */
					 <STM32_PINMUX('C', 12, ANALOG)>, /* SDMMC1_CK */
					 <STM32_PINMUX('D', 2, ANALOG)>; /* SDMMC1_CMD */
		};
	};

	uart4_pins_mx: uart4_mx-0 {
		u-boot,dm-pre-reloc;
		pins1 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
			bias-disable;
		};
		pins2 {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('G', 11, AF6)>; /* UART4_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	uart4_sleep_pins_mx: uart4_sleep_mx-0 {
		u-boot,dm-pre-reloc;
		pins {
			u-boot,dm-pre-reloc;
			pinmux = <STM32_PINMUX('B', 2, ANALOG)>, /* UART4_RX */
					 <STM32_PINMUX('G', 11, ANALOG)>; /* UART4_TX */
		};
	};


};



&sdmmc1{
	u-boot,dm-pre-reloc;
//	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-names = "default", "opendrain";
	pinctrl-0 = <&sdmmc1_pins_mx>;
	pinctrl-1 = <&sdmmc1_opendrain_pins_mx>;
//	pinctrl-2 = <&sdmmc1_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN sdmmc1 */
	broken-cd;
	disable-wp;
	st,neg-edge;
	bus-width = <4>;
	max-frequency = <10000000>;
	vmmc-supply = <&v3v3>;
	/* USER CODE END sdmmc1 */
};

&uart4{
	u-boot,dm-pre-reloc;
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&uart4_pins_mx>;
	pinctrl-1 = <&uart4_sleep_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN uart4 */
	/* USER CODE END uart4 */
};
